[{"content":"Adelitas Way  Still Hungry  AKB48  Love Trip 桜の栞  Alisa Takigawa  夏の花  All That Remains  What If I Was Nothing  Amon Amarth  Raven\u0026rsquo;s Flight War of the Gods  Architects  Doomsday  Ariel Tsai  剛好遇見你 (x)  Art Of Dying  Tear Down the Wall  As I Lay Dying  Blinded  Ashes Remain  End of Me  Asking Alexandria  Into The Fire  Back Number  クリスマスソング  聞こえるまで何度だって言うよ。君が好きだ。\n   Backstreet Boys  Show Me the Meaning of Being Lonely  Bad Wolves  Remember When Zombie  What\u0026rsquo;s in your head, in your head?\n   Beast In Black  Sweet True Lies  Bette Midler  The Rose  Lies the seed, that with the sun\u0026rsquo;s love in the spring becomes the rose.\n   BIGBANG  声をきかせて  Black Veil Brides  Wake Up When They Call My Name  I need you to tell me everything will be alright.\n   BoA  Every Heart  Breaking Benjamin  Psycho The Diary Of Jane  Brothers of Metal  Yggdrasil  Bullet For My Valentine  You Want a Battle? (Here\u0026rsquo;s a War)  Bury Tomorrow  Black Flame  Cana  あなたとずっと  Crown The Empire  What I am  CueStack  Alive  I want to be alive.\n   Daoko  打上花火  Dead by April  Crying Over You For Every Step  And every second for the rest of my life you will find me here.\n   Dead End Finland  War Forevermore  Demotional  Boiling point  Disturbed  A Reason to Fight Divisive Immortalized Indestructible  You will be shown. How I\u0026rsquo;ve become. Indestructible.\n  Inside the Fire Hold on to Memories  So now go do the best things in life. Take a bite of this world while you can.\n  Legion of Monsters No More  No more. No more.\n  Open Your Eyes Stronger on Your Own  And still you find yourself alone. You will begin to realize. That you are stronger on your own.\n  The Light  Sometimes darkness. Can show you the light.\n  The Sound of Silence The Vengeful One Unstoppable Warrior Who Taught You How to Hate  \u0026lsquo;Cause it isn\u0026rsquo;t in your blood. Not a part of what you\u0026rsquo;re made.\n  You\u0026rsquo;re Mine  Dream Ami  Lovefool  Dream Evil  The Book of Heavy Metal  Eluveitie  King  Enrique Iglesias  Why Not Me?  Escape The Fate  I Am Human  Evanescence  Bring Me To Life My Immortal  Fear Factory  Edgecrusher  Five Finger Death Punch  Gone Away  Maybe in another life. I could find you there.\n  Inside Out Under and Over It Wash It All Away  I\u0026rsquo;ve given up. On society. Up on my family. Up on your social disease.\n  When The Seasons Change  For The Fallen Dreams  Unstoppable  Gemini Syndrome  Remember We Die  Don\u0026rsquo;t let go. Just let the light shine from your soul.\n   Godsmack  Bulletproof  But I promise you that I\u0026rsquo;ll make sure you never forget me.\n  Under your scars  Green Day  21 Guns  Halestorm  I Am the Fire  Hikaru Utada  二時間だけのバカンス  Hồ Quỳnh Hương  Với Anh Em Vẫn Là Cô Bé (x)  Imagine Dragons  Natural  In Flames  I Am Above  This is the feeling that I have been waiting for.\n  It’s No Good Stay with Me  Stay with me.\n   Jasta, Howard Jones  Chasing Demons  Jay Chou  夜曲  Jewel  Jewel  Jonathan Davis  Basic Needs  There\u0026rsquo;s blood in my veins \u0026lsquo;cause I know you are there.\n   Kelly Chen  Love Paradise  You\u0026rsquo;re always on my mind.\n   Leo Ieiri  Relax  Like A Storm  Love the Way You Hate Me The Devil Inside  Linkin Park  Burn It Down Burning in the Skies Castle of Glass  \u0026lsquo;Cause I\u0026rsquo;m only a crack in this castle of glass.\n  From the Inside In the End Iridescent  Remember all the sadness and frustration. And let it go, let it go.\n  Leave Out All The Rest  And when you\u0026rsquo;re feeling empty. Keep me in your memory. Leave out all the rest.\n  New Divide  Let the floods cross. The distance in your eyes.\n  Numb One More Light  M2M  The Day You Went Away  Maiko Fujikta  素敵なことがあなたを待っている  いつか光は届くと。信じてるよ。\n   Michael Jackson  Heal the World  Make it a better place. For you and for me. And the entire human race.\n   Mika Nakashima  雪の花  Miyu Inoue  この空の果て  Mudvayne  Determined  Myles Kennedy  Love Can Only Heal  Namie Amuro  How do you feel now?  NGT48  世界の人へ  Nightwish  Elan While Your Lips Are Still Red  Nogizaka46  いつかできるから今日できる サヨナラの意味  Nonpoint  Breaking Skin  Orden Ogan  Come with Me to the Other Side Ravenhead  Pop Evil  Be Legendary  Powerwolf  Fire \u0026amp; Forgive  Richard Marx  Right Here Waiting  Wherever you go. Whatever you do. I will be right here waiting for you.\n   Righteous Vendetta  War Is Killing Us All  Shane Filan  Beautiful In White  Shayne Ward  Until You  Shinedown  Diamond Eyes  Skeletonwitch  Fen of Shadows  Slipknot  Killpop  Die and fucking love me.\n  Nero Forte  Spineshank  Beginning of the End Synthetic  SPITZ  チェリー  いつかまたこの場所で。君とめぐり会いたい。\n   Suraj Jagan  Give Me Some Sunshine  Give Me Some Sunshine. Give Me Some Rain.\n   Terror  Hard Lessons  The Red Jumpsuit Apparatus  Your Guardian Angel  The veer union  Bitter end  Theory of a Deadman  Angel  Thousand Foot Krutch  War of Change  Threat Signal  Through My Eyes  Trademark  Only Love  TVXQ!  どうして君を好きになってしまったんだろう？  Wanbi Tuấn Anh  Cho Em  Within Temptation  The Reckoning  Zero Theorem  Becoming  BEQUESTS \u0026amp; REQUESTS After payment of all of personal debts, expenses and liabilities, I request and direct that my property be bequeathed as follows: I give, devise and bequeath all of the remaining and residual property I have ownership in at the time of my death, whether real property, personal property or both, of whatever kind and wherever situated to @yuyuvn absolutely and entirely. In case of @yuyuvn not be living, then I give, devise and bequeath all of the remaining and residual property I have ownership in at the time of my death, whether real property, personal property or both, of whatever kind and wherever situated to Vietnam government absolutely and entirely.\nNote (x): Not listed in Spotify liked songs\n","description":"This is the list of songs which I want played at my funeral","id":0,"section":"posts","tags":null,"title":"My Will","uri":"https://blog.metalwhale.dev/posts/my-will/"},{"content":"Reference: Julia Documentation\nIntegers and Floating-Point Numbers Numeric Literal Coefficients  Allows variables to be immediately preceded by a numeric literal, implying multiplication:  1 2 3 4 5 6 7 8  julia\u0026gt; x = 3 3 julia\u0026gt; 2x^2 - 3x + 1 10 julia\u0026gt; 1.5x^2 - .5x + 1 13.0   Mathematical Operations and Elementary Functions Vectorized \u0026ldquo;dot\u0026rdquo; operators  For every binary operation like ^, there is a corresponding \u0026ldquo;dot\u0026rdquo; operation .^ that is automatically defined to perform ^ element-by-element on arrays:  1 2 3 4 5  julia\u0026gt; [1,2,3] .^ 3 3-element Array{Int64,1}: 1 8 27   Numeric Comparisons  Comparisons can be arbitrarily chained:  1 2  julia\u0026gt; 1 \u0026lt; 2 \u0026lt;= 2 \u0026lt; 3 == 3 \u0026gt; 2 \u0026gt;= 1 == 1 \u0026lt; 3 != 5 true   Operator Precedence and Associativity    Category Operators Associativity     Syntax . followed by :: Left   Exponentiation ^ Right   Unary + - √ Right   Bitshifts \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; Left   Fractions // Left   Multiplication * / % \u0026amp; \\ ÷ Left   Addition `+ - ⊻`   Syntax : .. Left   Syntax ` \u0026gt;`   Syntax `\u0026lt; `   Comparisons \u0026gt; \u0026lt; \u0026gt;= \u0026lt;= == === != !== \u0026lt;: Non-associative   Control flow `\u0026amp;\u0026amp; followed by    Pair =\u0026gt; Right   Assignments `= += -= *= /= //= = ^= ÷= %= = \u0026amp;= ⊻= \u0026laquo;= \u0026raquo;= \u0026raquo;\u0026gt;=`    Complex and Rational Numbers Complex Numbers  The global constant im is bound to the complex number i:  1 2  julia\u0026gt; 1+2im 1 + 2im   Rational Numbers  Represent exact ratios of integers:  1 2 3 4 5 6 7 8 9 10 11  julia\u0026gt; 6//9 2//3 julia\u0026gt; -4//8 -1//2 julia\u0026gt; 5//-15 -1//3 julia\u0026gt; -4//-12 1//3   Strings String Basics  String literals:  1 2 3 4 5  julia\u0026gt; str = \u0026#34;Hello, world.\\n\u0026#34; \u0026#34;Hello, world.\\n\u0026#34; julia\u0026gt; \u0026#34;\u0026#34;\u0026#34;Contains \u0026#34;quote\u0026#34; characters\u0026#34;\u0026#34;\u0026#34; \u0026#34;Contains \\\u0026#34;quote\\\u0026#34;characters\u0026#34;    Extract a character from a string:  1 2 3 4 5 6 7 8 9 10 11  julia\u0026gt; str[begin] \u0026#39;H\u0026#39;: ASCII/Unicode U+0048 (category Lu: Letter, uppercase) julia\u0026gt; str[1] \u0026#39;H\u0026#39;: ASCII/Unicode U+0048 (category Lu: Letter, uppercase) julia\u0026gt; str[6] \u0026#39;,\u0026#39;: ASCII/Unicode U+002C (category Po: Punctuation, other) julia\u0026gt; str[end] \u0026#39;\\n\u0026#39;: ASCII/Unicode U+000A (category Cc: Other, control)    Extract a substring using range indexing:  1 2  julia\u0026gt; str[4:9] \u0026#34;lo, wo\u0026#34;   Concatenation 1 2 3 4 5 6 7 8  julia\u0026gt; greet = \u0026#34;Hello\u0026#34; \u0026#34;Hello\u0026#34; julia\u0026gt; whom = \u0026#34;world\u0026#34; \u0026#34;world\u0026#34; julia\u0026gt; string(greet, \u0026#34;, \u0026#34;, whom, \u0026#34;.\\n\u0026#34;) \u0026#34;Hello, world.\\n\u0026#34;    Provides * for string concatenation:  1 2  julia\u0026gt; greet * \u0026#34;, \u0026#34; * whom * \u0026#34;.\\n\u0026#34; \u0026#34;Hello, world.\\n\u0026#34;   Interpolation  Allows interpolation into string literals using $:  1 2  julia\u0026gt; \u0026#34;$greet, $whom.\\n\u0026#34; \u0026#34;Hello, world.\\n\u0026#34;    Interpolate any expression into a string using parentheses:  1 2  julia\u0026gt; \u0026#34;1 + 2 = $(1 + 2)\u0026#34; \u0026#34;1 + 2 = 3\u0026#34;   Regular Expressions  The most basic regular expression literal without any options turned on just uses r\u0026quot;...\u0026quot;:  1 2 3 4 5  julia\u0026gt; r\u0026#34;^\\s*(?:#|$)\u0026#34; r\u0026#34;^\\s*(?:#|$)\u0026#34; julia\u0026gt; typeof(ans) Regex    To capture this information about a match, use the match function:  1 2 3 4  julia\u0026gt; match(r\u0026#34;^\\s*(?:#|$)\u0026#34;, \u0026#34;not a comment\u0026#34;) julia\u0026gt; match(r\u0026#34;^\\s*(?:#|$)\u0026#34;, \u0026#34;# a comment\u0026#34;) RegexMatch(\u0026#34;#\u0026#34;)   Version Number Literals  Expressed with non-standard string literals of the form v\u0026quot;...\u0026quot;:  1 2 3  if v\u0026#34;0.2\u0026#34; \u0026lt;= VERSION \u0026lt; v\u0026#34;0.3-\u0026#34; # do something specific to 0.2 release series end   Raw String Literals  Expressed with non-standard string literals of the form raw\u0026quot;...\u0026quot;:  1 2  julia\u0026gt; println(raw\u0026#34;\\\\\\\\\\\u0026#34;\u0026#34;) \\\\ \\\u0026#34;   Functions  Basic syntax:  1 2 3 4  julia\u0026gt; function f(x,y) x + y end f (generic function with 1 method)    Assignment form:  1 2  julia\u0026gt; f(x,y) = x + y f (generic function with 1 method)   The return Keyword  A return type can be specified in the function declaration using the :: operator:  1 2 3 4 5 6  julia\u0026gt; function g(x, y)::Int8 return x * y end; julia\u0026gt; typeof(g(1, 2)) Int8    Return the value nothing:  1 2 3 4  function printx(x) println(\u0026#34;x = $x\u0026#34;) return nothing end   Operators With Special Names    Expression Calls     [A B C ...] hcat   [A; B; C; ...] vcat   [A B; C D; ...] hvcat   A' adjoint   A[i] getindex   A[i] = x setindex!   A.n getproperty   A.n = x setproperty!    Anonymous Functions  Created anonymously, without being given a name:  1 2 3 4 5 6 7  julia\u0026gt; x -\u0026gt; x^2 + 2x - 1 #1 (generic function with 1 method) julia\u0026gt; function (x) x^2 + 2x - 1 end #3 (generic function with 1 method)   Named Tuples  The components of tuples can optionally be named:  1 2 3 4 5  julia\u0026gt; x = (a=1, b=1+1) (a = 1, b = 2) julia\u0026gt; x.a 1   Argument destructuring  If a function argument name is written as a tuple (e.g. (x, y)) instead of just a symbol, then an assignment (x, y) = argument will be inserted:  1 2 3 4 5 6  julia\u0026gt; minmax(x, y) = (y \u0026lt; x) ? (y, x) : (x, y) julia\u0026gt; range((min, max)) = max - min julia\u0026gt; range(minmax(10, 2)) 8   Varargs Functions  Taking an arbitrary number of arguments:  1 2  julia\u0026gt; bar(a,b,x...) = (a,b,x) bar (generic function with 1 method)    x is bound to a tuple of the trailing values passed to bar:  1 2 3 4 5 6 7 8 9 10 11  julia\u0026gt; bar(1,2) (1, 2, ()) julia\u0026gt; bar(1,2,3) (1, 2, (3,)) julia\u0026gt; bar(1, 2, 3, 4) (1, 2, (3, 4)) julia\u0026gt; bar(1,2,3,4,5,6) (1, 2, (3, 4, 5, 6))    \u0026ldquo;Splat\u0026rdquo; the values contained in an iterable collection into a function call as individual arguments:  1 2 3 4 5  julia\u0026gt; x = (3, 4) (3, 4) julia\u0026gt; bar(1,2,x...) (1, 2, (3, 4))    A tuple of values is spliced into a varargs call precisely where the variable number of arguments go:  1 2 3 4 5 6 7 8 9 10 11  julia\u0026gt; x = (2, 3, 4) (2, 3, 4) julia\u0026gt; bar(1,x...) (1, 2, (3, 4)) julia\u0026gt; x = (1, 2, 3, 4) (1, 2, 3, 4) julia\u0026gt; bar(x...) (1, 2, (3, 4))    The iterable object splatted into a function call need not be a tuple:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  julia\u0026gt; x = [3,4] 2-element Array{Int64,1}: 3 4 julia\u0026gt; bar(1,2,x...) (1, 2, (3, 4)) julia\u0026gt; x = [1,2,3,4] 4-element Array{Int64,1}: 1 2 3 4 julia\u0026gt; bar(x...) (1, 2, (3, 4))   Optional Arguments  Arguments have sensible default values and therefore might not need to be passed explicitly in every call:  1 2 3 4 5  function Date(y::Int64, m::Int64=1, d::Int64=1) err = validargs(Date, y, m, d) err === nothing || throw(err) return Date(UTD(totaldays(y, m, d))) end   Keyword Arguments  Allowing arguments to be identified by name instead of only by position:  1 2 3  function plot(x, y; style=\u0026#34;solid\u0026#34;, width=1, color=\u0026#34;black\u0026#34;) ### end    Extra keyword arguments can be collected using ...:  1 2 3  function f(x; y=0, kwargs...) ### end   Do-Block Syntax for Function Arguments 1 2 3 4 5 6 7 8 9  map([A, B, C]) do x if x \u0026lt; 0 \u0026amp;\u0026amp; iseven(x) return 0 elseif x == 0 return 1 else return x end end   Function composition and piping  Use the function composition operator (∘) to compose the functions:  1 2  julia\u0026gt; (sqrt ∘ +)(3, 6) 3.0    Function chaining:  1 2  julia\u0026gt; 1:10 |\u0026gt; sum |\u0026gt; sqrt 7.416198487095663   Dot Syntax for Vectorizing Functions  Any Julia function f can be applied elementwise to any array (or other collection) with the syntax f.(A):  1 2 3 4 5 6 7 8 9 10 11  julia\u0026gt; A = [1.0, 2.0, 3.0] 3-element Array{Float64,1}: 1.0 2.0 3.0 julia\u0026gt; sin.(A) 3-element Array{Float64,1}: 0.8414709848078965 0.9092974268256817 0.1411200080598672    The macro @. is provided to convert every function call, operation, and assignment in an expression into the \u0026ldquo;dotted\u0026rdquo; version:  1 2 3 4 5 6 7 8 9 10  julia\u0026gt; Y = [1.0, 2.0, 3.0, 4.0]; julia\u0026gt; X = similar(Y); # pre-allocate output array julia\u0026gt; @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y)) 4-element Array{Float64,1}: 0.5143952585235492 -0.4042391538522658 -0.8360218615377305 -0.6080830096407656   Control Flow Compound Expressions  An example of a begin block:  1 2 3 4 5 6  julia\u0026gt; z = begin x = 1 y = 2 x + y end 3    The ; chain syntax:  1 2  julia\u0026gt; z = (x = 1; y = 2; x + y) 3   Conditional Evaluation  The anatomy of the if-elseif-else conditional syntax:  1 2 3 4 5 6 7  if x \u0026lt; y println(\u0026#34;x is less than y\u0026#34;) elseif x \u0026gt; y println(\u0026#34;x is greater than y\u0026#34;) else println(\u0026#34;x is equal to y\u0026#34;) end   Repeated Evaluation: Loops  while loop:  1 2 3 4 5 6 7 8 9 10 11  julia\u0026gt; i = 1; julia\u0026gt; while i \u0026lt;= 5 println(i) global i += 1 end 1 2 3 4 5    for loop:  1 2 3 4 5 6 7 8  julia\u0026gt; for i = 1:5 println(i) end 1 2 3 4 5    The for loop construct can iterate over any container:  1 2 3 4 5 6 7 8 9 10 11 12 13  julia\u0026gt; for i in [1,4,0] println(i) end 1 4 0 julia\u0026gt; for s ∈ [\u0026#34;foo\u0026#34;,\u0026#34;bar\u0026#34;,\u0026#34;baz\u0026#34;] println(s) end foo bar baz    Multiple nested for loops can be combined into a single outer loop, forming the cartesian product of its iterables:  1 2 3 4 5 6 7  julia\u0026gt; for i = 1:2, j = 3:4 println((i, j)) end (1, 3) (1, 4) (2, 3) (2, 4)   Tasks (aka Coroutines)  A producer task, which produces values via the put! call:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  julia\u0026gt; function producer(c::Channel) put!(c, \u0026#34;start\u0026#34;) for n=1:4 put!(c, 2n) end put!(c, \u0026#34;stop\u0026#34;) end; julia\u0026gt; chnl = Channel(producer); julia\u0026gt; take!(chnl) \u0026#34;start\u0026#34; julia\u0026gt; take!(chnl) 2 julia\u0026gt; take!(chnl) 4 julia\u0026gt; take!(chnl) 6 julia\u0026gt; take!(chnl) 8 julia\u0026gt; take!(chnl) \u0026#34;stop\u0026#34;   Scope of Variables    Construct Scope type Scope blocks it may be nested in     module, baremodule global global   interactive prompt (REPL) global global   (mutable) struct, macro local global   for, while, try-catch-finally, let local global or local   functions (either syntax, anonymous \u0026amp; do-blocks) local global or local   comprehensions, broadcast-fusing local global or local    Local Scope  Inside a local scope a variable can be forced to be a new local variable using the local keyword:  1 2 3 4 5 6 7 8  julia\u0026gt; for i = 1:1 x = i + 1 for j = 1:1 local x = 0 end println(x) end 2    Inside a local scope a global variable can be assigned to by using the keyword global:  1 2 3 4 5 6 7  julia\u0026gt; for i = 1:10 global z z = i end julia\u0026gt; z 10    Nested functions can modify their parent scope\u0026rsquo;s local variables:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  julia\u0026gt; x, y = 1, 2; julia\u0026gt; function baz() x = 2 # introduces a new local function bar() x = 10 # modifies the parent\u0026#39;s x return x + y # y is global end return bar() + x # 12 + 10 (x is modified in call of bar()) end; julia\u0026gt; baz() 22 julia\u0026gt; x, y # verify that global x and y are unchanged (1, 2)    let statements allocate new variable bindings each time they run:  1 2 3 4 5 6 7 8  julia\u0026gt; x, y, z = -1, -1, -1; julia\u0026gt; let x = 1, z println(\u0026#34;x: $x, y: $y\u0026#34;) # x is local variable, y the global println(\u0026#34;z: $z\u0026#34;) # errors as z has not been assigned yet but is local end x: 1, y: -1 ERROR: UndefVarError: z not defined    Use let to create a new binding:  1 2 3 4 5 6 7 8 9 10 11 12 13 14  julia\u0026gt; Fs = Vector{Any}(undef, 2); i = 1; julia\u0026gt; while i \u0026lt;= 2 let i = i Fs[i] = ()-\u0026gt;i end global i += 1 end julia\u0026gt; Fs[1]() 1 julia\u0026gt; Fs[2]() 2    Since the begin construct does not introduce a new scope, it can be useful to use a zero-argument let to just introduce a new scope block without creating any new bindings:  1 2 3 4 5 6 7 8  julia\u0026gt; let local x = 1 let local x = 2 end x end 1    Reuse an existing local variable as the iteration variable:  1 2 3 4 5 6 7 8 9  julia\u0026gt; function f() i = 0 for outer i = 1:3 end return i end; julia\u0026gt; f() 3   Types Type Declarations  Declares the variable to always have the specified type:  1 2 3 4 5 6 7 8 9 10 11  julia\u0026gt; function foo() x::Int8 = 100 x end foo (generic function with 1 method) julia\u0026gt; foo() 100 julia\u0026gt; typeof(ans) Int8   Abstract Types  Abstract types are declared using the abstract type keyword:  1 2  abstract type «name» end abstract type «name» \u0026lt;: «supertype» end   Primitive Types  The general syntaxes for declaring a primitive type are:  1 2  primitive type «name» «bits» end primitive type «name» \u0026lt;: «supertype» «bits» end   Composite Types  Introduced with the struct keyword followed by a block of field names, optionally annotated with types using the :: operator:  1 2 3 4 5  julia\u0026gt; struct Foo bar baz::Int qux::Float64 end   Mutable Composite Types  If a composite type is declared with mutable struct instead of struct, then instances of it can be modified:  1 2 3 4 5 6 7 8 9 10 11 12  julia\u0026gt; mutable struct Bar baz qux::Float64 end julia\u0026gt; bar = Bar(\u0026#34;Hello\u0026#34;, 1.5); julia\u0026gt; bar.qux = 2.0 2.0 julia\u0026gt; bar.baz = 1//2 1//2   Type Unions  A type union is a special abstract type which includes as objects all instances of any of its argument types:  1 2 3 4 5 6 7 8 9 10 11  julia\u0026gt; IntOrString = Union{Int,AbstractString} Union{Int64, AbstractString} julia\u0026gt; 1 :: IntOrString 1 julia\u0026gt; \u0026#34;Hello!\u0026#34; :: IntOrString \u0026#34;Hello!\u0026#34; julia\u0026gt; 1.0 :: IntOrString ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64   Parametric Types  Type parameters are introduced immediately after the type name, surrounded by curly braces:  1 2 3 4  julia\u0026gt; struct Point{T} x::T y::T end    A correct way to define a method that accepts all arguments of type Point{T} where T is a subtype of Real is:  1 2 3  function norm(p::Point{\u0026lt;:Real}) sqrt(p.x^2 + p.y^2) end    Parametric abstract type declarations declare a collection of abstract types:  1  julia\u0026gt; abstract type Pointy{T} end    Constrain the range of T:  1  julia\u0026gt; abstract type Pointy{T\u0026lt;:Real} end   UnionAll Types  Ptr itself cannot be a normal data type, since without knowing the type of the referenced data the type clearly cannot be used for memory operations. The answer is that Ptr (or other parametric types like Array) is a different kind of type called a UnionAll type. The where keyword itself can be nested:  1 2 3 4 5  julia\u0026gt; const T1 = Array{Array{T,1} where T, 1} Array{Array{T,1} where T,1} julia\u0026gt; const T2 = Array{Array{T,1}, 1} where T Array{Array{T,1},1} where T   \u0026ldquo;Value types\u0026rdquo;  Accept Val instances as arguments:  1 2 3 4 5 6 7 8 9 10 11  julia\u0026gt; firstlast(::Val{true}) = \u0026#34;First\u0026#34; firstlast (generic function with 1 method) julia\u0026gt; firstlast(::Val{false}) = \u0026#34;Last\u0026#34; firstlast (generic function with 2 methods) julia\u0026gt; firstlast(Val(true)) \u0026#34;First\u0026#34; julia\u0026gt; firstlast(Val(false)) \u0026#34;Last\u0026#34;   Methods Parametric Methods  Method definitions can optionally have type parameters qualifying the signature:  1 2 3 4 5  julia\u0026gt; same_type(x::T, y::T) where {T} = true same_type (generic function with 1 method) julia\u0026gt; same_type(x,y) = false same_type (generic function with 2 methods)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  julia\u0026gt; same_type(1, 2) true julia\u0026gt; same_type(1, 2.0) false julia\u0026gt; same_type(1.0, 2.0) true julia\u0026gt; same_type(\u0026#34;foo\u0026#34;, 2.0) false julia\u0026gt; same_type(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;) true julia\u0026gt; same_type(Int32(1), Int64(2)) false    Method type parameters are not restricted to being used as the types of arguments: they can be used anywhere a value would be in the signature of the function or body of the function:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  julia\u0026gt; myappend(v::Vector{T}, x::T) where {T} = [v..., x] myappend (generic function with 1 method) julia\u0026gt; myappend([1,2,3],4) 4-element Array{Int64,1}: 1 2 3 4 julia\u0026gt; myappend([1,2,3],2.5) ERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64) Closest candidates are: myappend(::Array{T,1}, !Matched::T) where T at none:1 julia\u0026gt; myappend([1.0,2.0,3.0],4.0) 4-element Array{Float64,1}: 1.0 2.0 3.0 4.0 julia\u0026gt; myappend([1.0,2.0,3.0],4) ERROR: MethodError: no method matching myappend(::Array{Float64,1}, ::Int64) Closest candidates are: myappend(::Array{T,1}, !Matched::T) where T at none:1   Function-like objects  It is possible to make any arbitrary Julia object \u0026ldquo;callable\u0026rdquo; by adding methods to its type:  1 2 3 4 5 6 7 8 9 10 11 12 13  julia\u0026gt; struct Polynomial{R} coeffs::Vector{R} end julia\u0026gt; function (p::Polynomial)(x) v = p.coeffs[end] for i = (length(p.coeffs)-1):-1:1 v = v*x + p.coeffs[i] end return v end julia\u0026gt; (p::Polynomial)() = p(5)   1 2 3 4 5 6 7 8  julia\u0026gt; p = Polynomial([1,10,100]) Polynomial{Int64}([1, 10, 100]) julia\u0026gt; p(3) 931 julia\u0026gt; p() 2551   Constructors Outer Constructor Methods  Add functionality to a constructor by simply defining new methods:  1 2 3 4 5  julia\u0026gt; Foo(x) = Foo(x,x) Foo julia\u0026gt; Foo(1) Foo(1, 1)   Inner Constructor Methods  An inner constructor method is like an outer constructor method, except for two differences:  It is declared inside the block of a type declaration, rather than outside of it like normal methods. It has access to a special locally existent function called new that creates objects of the block\u0026rsquo;s type.    1 2 3 4 5  julia\u0026gt; struct OrderedPair x::Real y::Real OrderedPair(x,y) = x \u0026gt; y ? error(\u0026#34;out of order\u0026#34;) : new(x,y) end   Incomplete Initialization  Allows the new function to be called with fewer than the number of fields that the type has:  1 2 3 4  julia\u0026gt; mutable struct SelfReferential obj::SelfReferential SelfReferential() = (x = new(); x.obj = x) end   Modules    Import Command What is brought into scope Available for method extension     using MyModule All exported names (x and y), MyModule.x, MyModule.y and MyModule.p MyModule.x, MyModule.y and MyModule.p   using MyModule: x, p x and p    import MyModule MyModule.x, MyModule.y and MyModule.p MyModule.x, MyModule.y and MyModule.p   import MyModule.x, MyModule.p x and p x and p   import MyModule: x, p x and p x and p    ","description":"Julia manual at a glance","id":1,"section":"posts","tags":["Julia"],"title":"Julia Cheat Sheet","uri":"https://blog.metalwhale.dev/posts/julia-cheat-sheet/"},{"content":"Notation $w^l_{jk}$: the weight for the connection from the $k^{th}$ neuron in the $(l-1)^{th}$ layer to the $j^{th}$ neuron in the $l^{th}$ layer\n$b^l_j$: the bias of the $j^{th}$ neuron in the $l^{th}$ layer\n$L$: the number of layers in the network\nFeedforward Intermediate quantity $$z^l_j = \\sum_k w^l_{jk} a^{l-1}_k + b^l_j \\tag{1}$$\nActivation $$a^l_j = \\sigma(z^l_j) \\tag{2}$$\nCost $$C = \\frac{1}{2} \\sum_j (y_j-a^L_j)^2 \\tag{3}$$\nBackpropagate Partial derivatives of the last activations From $(3)$: $$\\Rightarrow \\frac{\\partial C}{\\partial a^L_j} = a^L_j-y_j$$\nPartial derivatives of the $z$ quantities From $(2)$: $$\\Rightarrow \\frac{\\partial a^l_j}{\\partial z^l_j} = \\sigma'(z^l_j) \\tag{2'}$$ Chain rule: $$\\frac{\\partial C}{\\partial z^l_j} = \\frac{\\partial C}{\\partial a^l_j} \\frac{\\partial a^l_j}{\\partial z^l_j} \\tag{4}$$ From $(2')$ and $(4)$: $$\\Rightarrow \\frac{\\partial C}{\\partial z^l_j} = \\frac{\\partial C}{\\partial a^l_j} \\sigma'(z^l_j)$$\nPartial derivatives of the activations in hidden layers From $(1)$: $$\\Rightarrow \\frac{\\partial z^l_j}{\\partial a^{l-1}_k} = w^l_{jk} \\tag{1'}$$ Chain rule: $$\\frac{\\partial C}{\\partial a^{l-1}_k} = \\sum_j \\frac{\\partial C}{\\partial z^l_j} \\frac{\\partial z^l_j}{\\partial a^{l-1}_k} \\tag{5}$$ From $(1')$ and $(5)$: $$\\Rightarrow \\frac{\\partial C}{\\partial a^{l-1}_k} = \\sum_j \\frac{\\partial C}{\\partial z^l_j} w^l_{jk}$$\nPartial derivatives of the weights From $(1)$: $$\\Rightarrow \\frac{\\partial z^l_j}{\\partial w^l_{jk}} = a^{l-1}_k \\tag{1''}$$ Chain rule: $$\\frac{\\partial C}{\\partial w^l_{jk}} = \\frac{\\partial C}{\\partial z^l_j} \\frac{\\partial z^l_j}{\\partial w^l_{jk}} \\tag{6}$$ From $(1'')$ and $(6)$: $$\\Rightarrow \\frac{\\partial C}{\\partial w^l_{jk}} = \\frac{\\partial C}{\\partial z^l_j} a^{l-1}_k$$\nPartial derivatives of the biases From $(1)$: $$\\Rightarrow \\frac{\\partial z^l_j}{\\partial b^l_j} = 1 \\tag{1'''}$$ Chain rule: $$\\frac{\\partial C}{\\partial b^l_j} = \\frac{\\partial C}{\\partial z^l_j} \\frac{\\partial z^l_j}{\\partial b^l_j} \\tag{7}$$ From $(1''')$ and $(7)$: $$\\Rightarrow \\frac{\\partial C}{\\partial b^l_j} = \\frac{\\partial C}{\\partial z^l_j}$$\n","description":"Backpropagation's fundamental equations","id":2,"section":"posts","tags":["Neural Network"],"title":"Backpropagation","uri":"https://blog.metalwhale.dev/posts/backpropagation/"}]